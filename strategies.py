from abc import ABC, abstractmethod
from typing import Any, List
import pandas as pd

class Strategy(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals for the given data.
        
        :param data: DataFrame containing price and other relevant data
        :return: A Series with the same index as data, containing trading signals
        """
        pass

    @abstractmethod
    def get_parameters(self) -> dict:
        """
        Return a dictionary of the strategy's parameters.
        
        :return: A dictionary with parameter names as keys and their values
        """
        pass

    @abstractmethod
    def set_parameters(self, parameters: dict) -> None:
        """
        Set the strategy's parameters.
        
        :param parameters: A dictionary with parameter names as keys and their values
        """
        pass

    def __str__(self) -> str:
        return f"{self.name} Strategy"
    
class TrendCrossoverStrategy(Strategy):
    def __init__(self, fast_column: str = 'trend_ema_fast', slow_column: str = 'trend_ema_slow'):
        """
        Initialize the Trend Crossover Strategy.

        :param fast_column: Name of the column for the fast moving average
        :param slow_column: Name of the column for the slow moving average
        """
        super().__init__("Trend Crossover")
        self.fast_column = fast_column
        self.slow_column = slow_column

    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals based on the crossover of fast and slow moving averages.

        :param data: DataFrame containing price and moving average data
        :return: A Series with trading signals (1 for buy, -1 for sell, 0 for no action)
        """
        signals = pd.Series(index=data.index, data=0)
        
        crossover_up = (data[self.fast_column].shift(1) < data[self.slow_column].shift(1)) & \
                       (data[self.fast_column] > data[self.slow_column])
        crossover_down = (data[self.fast_column].shift(1) > data[self.slow_column].shift(1)) & \
                         (data[self.fast_column] < data[self.slow_column])
        
        signals[crossover_up] = 1
        signals[crossover_down] = -1
        
        return signals

    def get_parameters(self) -> dict:
        """
        Get the current parameters of the strategy.

        :return: A dictionary containing the fast and slow column names
        """
        return {
            "fast_column": self.fast_column,
            "slow_column": self.slow_column
        }

    def set_parameters(self, parameters: dict) -> None:
        """
        Set new parameters for the strategy.

        :param parameters: A dictionary containing new values for fast_column and/or slow_column
        """
        self.fast_column = parameters.get("fast_column", self.fast_column)
        self.slow_column = parameters.get("slow_column", self.slow_column)

class MLModelStrategy(Strategy):
    def __init__(self, name: str, model: Any, feature_columns: List[str], task: str = 'classification'):
        """
        Initialize the ML Model Strategy.

        :param name: Name of the strategy
        :param model: The machine learning model to use for predictions
        :param feature_columns: List of column names to use as features for the model
        :param task: 'classification' or 'regression'
        """
        super().__init__(name)
        self.model = model
        self.feature_columns = feature_columns
        self.task = task
        if task not in ['classification', 'regression']:
            raise ValueError("Task must be either 'classification' or 'regression'")

    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals using the ML model.

        :param data: DataFrame containing feature data
        :return: A Series with trading signals generated by the model
        """
        # Ensure all feature columns are present in the data
        if not all(col in data.columns for col in self.feature_columns):
            missing_cols = set(self.feature_columns) - set(data.columns)
            raise ValueError(f"Missing columns in data: {missing_cols}")

        features = data[self.feature_columns]

        predictions = self.model.predict(features)

        if self.task == 'classification':
            signals = pd.Series(predictions, index=data.index)
        elif self.task == 'regression':
            # For regression, we need to compare the predicted price with the next day's open price
            next_day_open = data['Open'].shift(-1)
            signals = pd.Series(index=data.index)
            signals[predictions > next_day_open] = 1  # Buy signal
            signals[predictions <= next_day_open] = -1  # Sell signal
            signals = signals.shift(1)  # Shift signals by 1 day to avoid look-ahead bias

        return signals

    def get_parameters(self) -> dict:
        """
        Get the current parameters of the strategy.

        :return: A dictionary containing the model, feature columns, and task
        """
        return {
            "model": self.model,
            "feature_columns": self.feature_columns,
            "task": self.task
        }

    def set_parameters(self, parameters: dict) -> None:
        """
        Set new parameters for the strategy.

        :param parameters: A dictionary containing new values for model, feature_columns, and/or task
        """
        self.model = parameters.get("model", self.model)
        self.feature_columns = parameters.get("feature_columns", self.feature_columns)
        new_task = parameters.get("task", self.task)
        if new_task in ['classification', 'regression']:
            self.task = new_task
        else:
            raise ValueError("Task must be either 'classification' or 'regression'")

class Condition(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def evaluate(self, data: pd.DataFrame) -> pd.Series:
        """
        Evaluate the condition on the given data.

        :param data: DataFrame containing relevant data for condition evaluation
        :return: A Series with boolean values indicating where the condition is met
        """
        pass

    def __str__(self) -> str:
        return f"{self.name} Condition"
    
class VolatilityCondition(Condition):
    def __init__(self, column: str = 'volatility_atr', threshold: float = 1.75):
        """
        Initialize the Volatility Condition.

        :param column: Name of the column containing volatility data
        :param threshold: Threshold value for the volatility condition
        """
        super().__init__("Volatility")
        self.column = column
        self.threshold = threshold

    def evaluate(self, data: pd.DataFrame) -> pd.Series:
        """
        Evaluate if the volatility is above the threshold.

        :param data: DataFrame containing volatility data
        :return: A Series with boolean values indicating where volatility is above the threshold
        """
        return (data[self.column] > self.threshold).astype(int)